package security

import (
	"fmt"
	"path/filepath"
	"strings"

	"goa.design/goa/codegen"
	"goa.design/goa/codegen/service"
	goadesign "goa.design/goa/design"
	"goa.design/goa/eval"
	"goa.design/goa/http/codegen/openapi"
	seccodegen "goa.design/plugins/security/codegen"
	"goa.design/plugins/security/design"

	// Initializes the HTTP generator
	_ "goa.design/plugins/security/http"
)

type (
	// ServiceData contains the data necessary to render the secure endpoints
	// constructor.
	ServiceData struct {
		// Name is the name of the service.
		Name string
		// VarName is the Go name of the service interface.
		VarName string
		// PkgName is the name of the service package.
		PkgName string
		// SecurityPkgName is the name of the security package.
		SecurityPkgName string
		// EndpointsVarName is the Go endpoints struct name.
		EndpointsVarName string
		// Methods list the endpoint constructors.
		Methods []*MethodData
	}

	// MethodData contains the data necessry to render
	// endpoints.
	MethodData struct {
		// VarName is the goified name of the constructor method. It
		// differs to the name generated by goa when the endpoint
		// defines security scheme.
		VarName string
		// NonSecureVarName is the goified name of constructor method
		// generated by goa.
		NonSecureVarName string
		// FieldName is the name of the corresponding endpoints struct
		// field.
		FieldName string
		// ServiceName is the name of the corresponding service.
		ServiceName string
		// MethodName is the name of the corresponding service method.
		MethodName string
		// Payload is the payload type from which to extract information.
		Payload string
		// PayloadRef is the reference to the payload.
		PayloadRef string
		// Requirements lists the security requirements that apply to
		// the secured method.
		Requirements []*design.SecurityExpr
		// SecurityPkgName is the name of the security package.
		SecurityPkgName string
		// Schemes is the security schemes for the method.
		Schemes []*seccodegen.SchemeData
	}

	// AuthorizeFuncs is the type for holding the authorization functions used by
	// the service endpoints. It is a map with key as the scheme type and value
	// as the authorize function type.
	AuthorizeFuncs map[string]string
)

// Register the plugin Generator functions.
func init() {
	codegen.RegisterPlugin("gen", Generate)
	codegen.RegisterPlugin("example", Example)
}

// Generate produces server code that enforce the security requirements defined
// in the design. Generate also produces client code that makes it possible to
// provide the required security artifacts. Finally Generate also generate code
// that initializes the context given to the service methods with security
// information.
func Generate(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	for _, root := range roots {
		switch r := root.(type) {
		case *goadesign.RootExpr:
			for _, s := range r.Services {
				if f := SecureEndpointFile(genpkg, s); f != nil {
					files = append(files, f)
				}
			}
		case *design.RootExpr:
			for _, f := range files {
				OpenAPIV2(r, f)
			}
		}
	}
	return files, nil
}

// Example modified the generated main function so that the secured endpoints
// context gets initialized with the security requirements.
func Example(genpkg string, roots []eval.Root, files []*codegen.File) ([]*codegen.File, error) {
	var (
		data   *ServiceData
		apiPkg string
	)
	for _, root := range roots {
		switch r := root.(type) {
		case *goadesign.RootExpr:
			apiPkg = strings.ToLower(codegen.Goify(r.API.Name, false))
			for _, s := range r.Services {
				data = BuildSecureServiceData(s)
			}
		}
	}
	if data != nil {
		svcSchemes := data.Schemes()
		authFuncs := make([]string, 0, len(svcSchemes))
		for _, s := range svcSchemes {
			authFuncs = append(authFuncs, fmt.Sprintf("%s.Auth%sFn", apiPkg, s.Type()))
		}
		for _, f := range files {
			for _, s := range f.Section("service-main") {
				s.Source = strings.Replace(
					s.Source,
					"{{ .Service.PkgName }}Endpoints = {{ .Service.PkgName }}.NewEndpoints({{ .Service.PkgName }}Svc)",
					fmt.Sprintf("{{ .Service.PkgName }}Endpoints = {{ .Service.PkgName }}.NewSecureEndpoints({{ .Service.PkgName }}Svc, %s)", strings.Join(authFuncs, ", ")),
					1,
				)
			}
			if s := f.Section("dummy-endpoint"); len(s) > 0 {
				for _, h := range f.Section("source-header") {
					codegen.AddImport(h, codegen.SimpleImport("goa.design/plugins/security"))
					codegen.AddImport(h, codegen.SimpleImport("fmt"))
				}
				f.SectionTemplates = append(f.SectionTemplates, &codegen.SectionTemplate{
					Name:   "dummy-authorize-funcs",
					Source: dummyAuthFuncsT,
					Data:   data,
				})
			}
		}
	}
	return files, nil
}

// OpenAPIV2 updates the openapi.json file with the security definitions.
func OpenAPIV2(r *design.RootExpr, f *codegen.File) {
	for _, s := range f.Section("openapi") {
		spec := s.Data.(*openapi.V2)
		spec.SecurityDefinitions = buildV2SecurityDefinitions(r.Schemes)
		s.Data = spec
	}
}

func buildV2SecurityDefinitions(schemes []*design.SchemeExpr) map[string]*openapi.SecurityDefinition {
	sds := make(map[string]*openapi.SecurityDefinition)
	for _, s := range schemes {
		sd := openapi.SecurityDefinition{
			Description: s.Description,
			Extensions:  openapi.ExtensionsFromExpr(s.Metadata),
		}
		switch s.Kind {
		case design.BasicAuthKind:
			sd.Type = "basic"
		case design.APIKeyKind:
			sd.Type = "apiKey"
			sd.In = s.In
			if sd.In == "" {
				sd.In = "header"
			}
			sd.Name = s.Name
			if sd.Name == "" {
				sd.Name = "key"
			}
		case design.JWTKind:
			sd.Type = "apiKey"
			sd.In = s.In
			if sd.In == "" {
				sd.In = "header"
			}
			sd.Name = s.Name
			if sd.Name == "" {
				sd.Name = "token"
			}
			// OpenAPI V2 spec does not support JWT scheme. Hence we add the scheme
			// information to the description.
			lines := []string{}
			for _, scope := range s.Scopes {
				lines = append(lines, fmt.Sprintf("  * `%s`: %s", scope.Name, scope.Description))
			}
			sd.Description += fmt.Sprintf("\n**Security Scopes**:\n%s", strings.Join(lines, "\n"))
		case design.OAuth2Kind:
			sd.Type = "oauth2"
			if scopesLen := len(s.Scopes); scopesLen > 0 {
				scopes := make(map[string]string, scopesLen)
				for _, scope := range s.Scopes {
					scopes[scope.Name] = scope.Description
				}
				sd.Scopes = scopes
			}
		}
		if len(s.Flows) > 0 {
			switch s.Flows[0].Kind {
			case design.AuthorizationCodeFlowKind:
				sd.Flow = "accessCode"
			case design.ImplicitFlowKind:
				sd.Flow = "implicit"
			case design.PasswordFlowKind:
				sd.Flow = "password"
			case design.ClientCredentialsFlowKind:
				sd.Flow = "application"
			}
			sd.AuthorizationURL = s.Flows[0].AuthorizationURL
			sd.TokenURL = s.Flows[0].TokenURL
		}
		sds[s.SchemeName] = &sd
	}
	return sds
}

// SecureEndpointFile returns the file containing the secure endpoint
// definitions.
func SecureEndpointFile(genpkg string, svc *goadesign.ServiceExpr) *codegen.File {
	data := BuildSecureServiceData(svc)
	path := filepath.Join(codegen.Gendir, codegen.SnakeCase(svc.Name), "security.go")
	header := codegen.Header(
		svc.Name+" service security",
		data.PkgName,
		[]*codegen.ImportSpec{
			{Path: "context"},
			{Path: "goa.design/goa"},
			{Path: "goa.design/plugins/security"},
		})
	sections := []*codegen.SectionTemplate{header}
	sections = append(sections, &codegen.SectionTemplate{
		Name:    "secure-endpoint-init",
		Source:  secureEndpointsInitT,
		Data:    data,
		FuncMap: codegen.TemplateFuncs(),
	})
	for _, m := range data.Methods {
		if len(m.Requirements) == 0 {
			continue
		}
		sections = append(sections, &codegen.SectionTemplate{
			Name:   "secure-endpoint",
			Source: secureEndpointT,
			Data:   m,
		})
	}
	if len(sections) == 1 {
		return nil
	}
	return &codegen.File{
		Path:             path,
		SectionTemplates: sections,
	}
}

// BuildSecureServiceData builds the data needed to render the secured endpoints
// struct constructor and the secure endpoint methods.
func BuildSecureServiceData(svc *goadesign.ServiceExpr) *ServiceData {
	s := service.Services.Get(svc.Name)
	data := &ServiceData{
		Name:             svc.Name,
		PkgName:          s.PkgName,
		SecurityPkgName:  "security",
		VarName:          service.ServiceInterfaceName,
		EndpointsVarName: service.EndpointsStructName,
	}
	for _, m := range svc.Methods {
		reqs := design.Requirements(svc.Name, m.Name)
		md := s.Method(m.Name)
		varn := md.VarName
		cn := "New" + varn
		if len(reqs) > 0 {
			cn = "Secure" + varn
		}
		var schemeData []*seccodegen.SchemeData
		for _, req := range reqs {
			for _, sch := range req.Schemes {
				schemeData = append(schemeData, seccodegen.BuildSchemeData(sch, m))
			}
		}
		data.Methods = append(data.Methods, &MethodData{
			VarName:          cn,
			NonSecureVarName: "New" + varn + "Endpoint",
			FieldName:        varn,
			ServiceName:      svc.Name,
			MethodName:       m.Name,
			Payload:          md.Payload,
			PayloadRef:       md.PayloadRef,
			Requirements:     reqs,
			SecurityPkgName:  data.SecurityPkgName,
			Schemes:          schemeData,
		})
	}
	return data
}

// Schemes returns the unique security schemes used by all the endpoints
// in the service.
func (s *ServiceData) Schemes() []*design.SchemeExpr {
	var schemes []*design.SchemeExpr
	schemesFound := map[design.SchemeKind]bool{}
	for _, m := range s.Methods {
		for _, e := range m.Schemes {
			if _, ok := schemesFound[e.Scheme.Kind]; ok {
				continue
			}
			schemes = append(schemes, e.Scheme)
			schemesFound[e.Scheme.Kind] = true
		}
	}
	return schemes
}

// SchemeData returns the scheme data for the given scheme.
func (m *MethodData) SchemeData(s *design.SchemeExpr) *seccodegen.SchemeData {
	for _, e := range m.Schemes {
		if e.Scheme.Kind == s.Kind {
			return e
		}
	}
	return nil
}

// input: securedServiceData
const secureEndpointsInitT = `{{ printf "NewSecure%s wraps the methods of a %s service with security scheme aware endpoints." .EndpointsVarName .Name | comment }}
	func NewSecure{{ .EndpointsVarName }}(s {{ .VarName }}{{ range .Schemes }}, auth{{ .Type }}Fn {{ $.SecurityPkgName }}.Authorize{{ .Type }}Func{{ end }}) *{{ .EndpointsVarName }} {
		return &{{ .EndpointsVarName }}{
			{{- range .Methods }}
			{{ .FieldName }}: {{ if .Requirements }}{{ .VarName }}({{ end }}{{ .NonSecureVarName }}(s){{ if .Requirements }}{{ range .Schemes }}, auth{{ .Scheme.Type }}Fn{{ end }}){{ end }},
			{{- end }}
		}
	}
`

// input: securedServiceMethodData
const secureEndpointT = `{{ printf "%s returns an endpoint function which initializes the context with the security requirements for the method %q of service %q." .VarName .MethodName .ServiceName | comment }}
func {{ .VarName }}(ep goa.Endpoint{{ range .Schemes }}, auth{{ .Scheme.Type }}Fn {{ $.SecurityPkgName }}.Authorize{{ .Scheme.Type }}Func{{ end }}) goa.Endpoint {
	return func(ctx context.Context, req interface{}) (interface{}, error) {
		p := req.({{ if .PayloadRef }}*{{ end }}{{ .Payload }})
		var err error
		{{- range $ridx, $r := .Requirements }}
			{{- if ne $ridx 0 }}
		if err != nil {
			{{- end }}
			{{- range $sidx, $s := .Schemes }}
				{{- $scheme := $.SchemeData $s }}
				{{- if ne $sidx 0 }}
			if err == nil {
				{{- end }}
				{{- if eq .Type "BasicAuth" }}
				basicAuthSch := {{ $.SecurityPkgName }}.BasicAuthScheme{
					Name: {{ printf "%q" .SchemeName }},
				}
				ctx, err = auth{{ .Type }}Fn(ctx, {{ if $scheme.UsernamePointer }}*{{ end }}p.{{ $scheme.UsernameField }}, {{ if $scheme.PasswordPointer }}*{{ end }}p.{{ $scheme.PasswordField }}, &basicAuthSch)

				{{- else if eq .Type "APIKey" }}
				apiKeySch := {{ $.SecurityPkgName }}.APIKeyScheme{
					Name: {{ printf "%q" .SchemeName }},
				}
				ctx, err = auth{{ .Type }}Fn(ctx, {{ if $scheme.CredPointer }}*{{ end }}p.{{ $scheme.CredField }}, &apiKeySch)

				{{- else if eq .Type "JWT" }}
				jwtSch := {{ $.SecurityPkgName }}.JWTScheme{
					Name: {{ printf "%q" .SchemeName }},
					Scopes: []string{ {{- range .Scopes }}{{ printf "%q" .Name }}, {{ end }} },
					RequiredScopes: []string{ {{- range $r.Scopes }}{{ printf "%q" . }}, {{ end }} },
				}
				ctx, err = auth{{ .Type }}Fn(ctx, {{ if $scheme.CredPointer }}*{{ end }}p.{{ $scheme.CredField }}, &jwtSch)

				{{- else if eq .Type "OAuth2" }}
				oauth2Sch := {{ $.SecurityPkgName }}.OAuth2Scheme{
					Name: {{ printf "%q" .SchemeName }},
					Scopes: []string{ {{- range .Scopes }}{{ printf "%q" .Name }}, {{ end }} },
					RequiredScopes: []string{ {{- range $r.Scopes }}{{ printf "%q" . }}, {{ end }} },
					{{- if .Flows }}
					Flows: []*security.OAuthFlow{
						{{- range .Flows }}
						&security.OAuthFlow{
							Type: "{{ .Type }}",
							{{- if .AuthorizationURL }}
							AuthorizationURL: {{ printf "%q" .AuthorizationURL }},
							{{- end }}
							{{- if .TokenURL }}
							TokenURL: {{ printf "%q" .TokenURL }},
							{{- end }}
							{{- if .RefreshURL }}
							RefreshURL: {{ printf "%q" .RefreshURL }},
							{{- end }}
						},
						{{- end }}
					},
					{{- end }}
				}
				ctx, err = auth{{ .Type }}Fn(ctx, {{ if $scheme.CredPointer }}*{{ end }}p.{{ $scheme.CredField }}, &oauth2Sch)

				{{- else }}
				{{ printf "unsupported scheme type %q" .Type | comment }}

				{{- end }}
				{{- if ne $sidx 0 }}
				}
				{{- end }}
			{{- end }}
			{{- if ne $ridx 0 }}
		}
			{{- end }}
		{{- end }}
		if err != nil {
			return nil, err
		}
		return ep(ctx, req)
	}
}
`

const dummyAuthFuncsT = `{{- range .Schemes }}

{{ printf "Auth%sFn implements the authorization logic for %s scheme." .Type .Type | comment }}
func Auth{{ .Type }}Fn(ctx context.Context, {{ if eq .Type "BasicAuth" }}user, pass{{ else if eq .Type "APIKey" }}key{{ else }}token{{ end }} string, s *{{ $.SecurityPkgName }}.{{ .Type }}Scheme) (context.Context, error) {
	// Add authorization logic
	{{- if eq .Type "BasicAuth" }}
	if user == "" {
		return ctx, fmt.Errorf("invalid username")
	}
	if pass == "" {
		return ctx, fmt.Errorf("invalid password")
	}
	{{- else if eq .Type "APIKey" }}
	if key == "" {
		return ctx, fmt.Errorf("invalid key")
	}
	{{- else }}
	if token == "" {
		return ctx, fmt.Errorf("invalid token")
	}
	{{- end }}
	return ctx, nil
}
{{ end }}
`
